






\section{Design}
\label{design}
%\paul{I left the citations blank and someone else should read through} %\pat{I commented them out until they are fixed, personally I'm not sure they are needed}
In order to fulfill the goals of \texttt{BeeSwarm} the software architecture required would require that we both leverage industry standards, while at the same time implementing new functionality to \texttt{BEE}\cite{bee}. \texttt{BeeSwarm} is a general solution that can be deployed on any git repository, any CI service and any BEE-supported computing platform. For the purposes of example the software platforms \texttt{GitHub}, 
\texttt{Travis CI}, and \texttt{Chameleon Cloud}\cite{mambretti2015next}
were utilized. \textbf{Fig. \ref{arch}} shows the architecture of \texttt{BeeSwarm}. \texttt{BEE} is at the core of the architecture and serves a number of vital roles. As part of the continuous integration process \texttt{BEE} is deployed on the CI test environment, from there it is responsible for manging the workflow associated with creating a scalable test environment, copying required test scripts, initiating the target application, and finally parsing the output. %As with \texttt{BEE}\cite{bee} this is accomplished via Python scripting and benefits by using the same configurations (.beefile) for defining the process. By adding \texttt{BeeSwarm} to \texttt{BEE} it allows for easy implementation into any existing \texttt{BEE} environment. 
\textbf{Fig. \ref{overall}} shows the workflow of Travis CI with \texttt{BeeSwarm}. Once developers make commits to the central code repository, the original CI correctness test will be triggered. If the test finishes without a fail, \texttt{BeeSwarm} will start to deploy the scalability on BEE-supported computing platform, gather the results and push back to the code repository. It crucial that we use \texttt{BeeSwarm} to conduct scalability test, since the CI test environment is usually deployed on a single machine incapable for large-scale scalability test. There are four major design tasks in \texttt{BeeSwarm} and we discuss them as follows.




%In this section, we show the design detail of \texttt{BeeSwarm}. 




%\paul{Perhaps a silly question but should the X-axis be defined, I don't think it is clear what is is representing?}


\subsection{Integrate BEE in CI Test Environment}
Each time a developer commits to the central code repository, a new CI test job is triggered on the Travis CI test environment on virtual machines. That means in order to launch BEE inside that test environment, we need to install BEE every time before the scalability test. To minimize overhead caused by the installation, we designed a more efficient customized BEE installer for the Travis CI environment. Since BEE does not run any test locally in the Travis CI environment, we remove the image building process that was originally in the BEE installer, required when BEE runs jobs in a virtual machine on a system. %\pat{only required for bee-vm so I added virtual machine take it out if you like} \paul{I agree with Pat}
Also, we design a simplified BEE launcher (discussed in the next subsection), which requires less dependent packages/libraries, simplifying the BEE installer. Finally, to enable remote control of compute platforms through SSH, we add SSH key generation in the new BEE installer. This was not present in the original BEE installer, since it can utilize the current user's key. With all these optimizations, we are able to keep the BEE installation time to less than two minutes, causing only a slight overhead compared with minutes to hours of Travis CI test and scalability test.

\subsection{Customize BEE Launcher for CI Test Environment}
BEE was designed to handle multiple tasks simultaneously, so it adopted a server-client structure, in which the server is a centralized controller (i.e., \texttt{BEE Orchestration Controller}) that stores the global information of all running BEE jobs and clients, a series of BEE launchers (each targeting a computing platform). This structure can facilitate normal use, however it can be cumbersome to launch BEE jobs on a Travis CI test environment using the server-client structure (first start the \texttt{BEE Orchestration Controller} in the background and then launch the job using the BEE launcher).  Since we only run one BEE job for each Travis CI job, there is no need to use the centralized controller to keep all the information of multiple jobs. So, in this work we design a simplified BEE launcher. It allows Travis to launch the BEE job with just one simple command. Basically, we integrate the input parser and job launching process together in our simplified BEE launcher.

\subsection{Test Scalability  on BEE-supported Platform}
Since Travis CI only allocates one computing node (virtual machine) for each job, it is impractical to conduct a scalability test beyond one node. So, in this work we choose to use BEE as the computing back-end for the scalability test. BEE supports launching any kind of computing task on a variety of computing platforms, ranging from HPC systems to cloud computing systems (e.g., Amazon EC2, OpenStack). It can launch each job on as many nodes as each computing platform allows. BEE takes a job description file, \texttt{Beefile}, as input, that specifies all job related information including selecting the target platform, name tag of the Docker container for the application, and run scripts that the user specifies to be run when the application is deployed on the target platform. To launch a BEE job for the scalability test, we keep using the same \texttt{Beefile} as the job description. To specify specific test configurations for the scalability test, users only need to add multiple entries to the "mpirun" section inside the \texttt{Beefile}. Deploying the execution environment on the target system can take several minutes, to avoid setting up the environment repeatedly for each test, the BEE-CI launcher will first scan through the \texttt{Beefile}, and then setup the environment with the maximum number of nodes needed to conduct all tests. 

\subsection{Collect and Store Scalability Test Results}
Unlike common CI tests that only provide results in the form of ``\textit{pass}'' or ``\textit{no pass}'' to developers, scalability test reports a variety of information generated from different execution scales to developers. Since the information that developers care about is different from application to application, it is hard to develop a universal monitor strategy to gather information that suits everyone's needs. So instead, we leave this part to the developers. We let developers program their applications so that after each run the application will output relevant information. BEE will gather all the outputs from different runs as separate files, transfered and saved in the Travis CI test environment. Next, we require the developer to provide an output parser that can parse all relevant information from the output files and generate one final result file. Finally, BEE will push the final result file back to the central code repository and rename the file using the git build number to distinguish final result files generated from different commits. %\pat{I know you are using this for scalability results but it could also be used for correctness validation} 